<?xml version="1.0" encoding="utf-8"?>                                                                                                                                    
<mx:Canvas 
	xmlns:mx="http://www.adobe.com/2006/mxml"
	horizontalScrollPolicy="off" 
	verticalScrollPolicy="off"
	useHandCursor="true" 
	buttonMode="true"
	height="6"
	width="100%"
	backgroundColor="#cccccc"
	backgroundAlpha=".6"
	click="seekVideoTo(timeFromPoint(this.contentMouseX));" 
	initialize="init()"
	clipContent="false"
	resize="placeGrid();"
	>
	
	<mx:Script>
		<![CDATA[
			[Bindable] public var showTime:Boolean = true;
		]]>
	</mx:Script>
	
	<!-- Video Grid -->
	<mx:HBox 
		id="videoGrid" 
		top="0" 
		x="0"  
		width="100%" 
		height="100%" 
		horizontalGap="0" 
		/>
	
	<!-- VideoProgress -->
	<mx:Canvas id="videoProgress"
			   top="0" 
			   x="0"  
			   width="100%" 
			   height="100%" 
			   >
		<mx:Canvas id="videoPlayProgress" 
				   x="0"
				   height="5"
				   backgroundColor="white"
				   />
	</mx:Canvas>					

	<mx:Label id="videoTimeLabel"
			  right="-2"
			  y="5"
			  selectable="false"
			  fontFamily="Helvetica, Arial"
			  fontSize="9"
			  color="white"
			  />
	
	<mx:Script>
		<![CDATA[
			import com.philemonworks.flex.util.HashCollection;
			import com.visual.VisualVideo;
			
			import mx.core.Application;
			import mx.events.VideoEvent;
			[bindable] private var props:HashCollection = mx.core.FlexGlobals.topLevelApplication.props;
			[bindable] private var activeElement:HashCollection = mx.core.FlexGlobals.topLevelApplication.activeElement;
			
			private var _photos:Array = [];
			[Bindable] private var totalPlaylistLength:int = 1;
			public function set photos(p:Array) {
				_photos = p;
				
				for (var i:int = 0; i<_photos.length; i++) {
					totalPlaylistLength += new Number(_photos[i].video_length);
				}
				//totalTimeLabel.text = formatTime(totalPlaylistLength);
				placeGrid();
			}
			
			var scrubberStartX:int = -1;
			var scrubberStartMouseX:int = -1;
			private function init():void {
			}
			
			// Component-specific functions and event-handlers
			private function formatTime(time:int, totalTime:int = -1, join:String = ' / '):String {
				if (time<0) return("");
				if (totalTime>=0) {
					return([formatTime(time), formatTime(totalTime)].join(join));
				} else {
					var hours = Math.floor(time/3600);
					time -= hours*3600;
					return((hours>0 ? hours + ':' : '') + Math.floor(time/60).toString() +':'+ (time%60<10?'0':'') + Math.round(time%60).toString());
				}
			}
			private function timeFromPoint(x:int):int {
				return Math.round((x)/this.width*totalPlaylistLength);
			}
			public function seekVideoTo(time:int):void {
				if(!_targetVideo) return;
				if(time>totalPlaylistLength) return;
				var approxBufferTime:Number = (_targetVideo.totalTime * (_targetVideo.bytesLoaded/_targetVideo.bytesTotal)) + activeElement.getNumber('offset');
				_targetVideo.bufferTime = 2; // default buffer time is two secs
				
				var offset:Number = 0; 
				for (var i:int = 0; i<this.parentApplication.context.photos.length; i++) {
					offset += new Number(this.parentApplication.context.photos[i].video_length);
					if(offset>time) {
						if(_targetVideo.playing) _targetVideo.stop();
						// Skip to clip, but don't play yet
						this.parentApplication.setActiveElement(i, false);
						// Set start time
						activeElement.put('start', time-(offset-this.parentApplication.context.photos[i].video_length));
						activeElement.put('skip', '1');
						// Update source, then play
						_targetVideo.source = getFullVideoSource();
						this.parentApplication.playVideoElement();
						break;
					}
				}
			}
			private function updateProgressCanvas():void {
				videoProgress.x = (activeElement.getNumber('offset')/totalPlaylistLength * this.width);
				videoProgress.width = activeElement.getNumber('length')/totalPlaylistLength * this.width;
			}
			private function updatePlay(e:Event):void {
				if(!_targetVideo) return;
				updateProgressCanvas();
				videoPlayProgress.x = activeElement.getNumber('start') / activeElement.getNumber('length') * videoProgress.width;
				videoPlayProgress.width = _targetVideo.playheadTime/_targetVideo.totalTime*(videoProgress.width-videoPlayProgress.x);
				videoTimeLabel.text = formatTime(_targetVideo.playheadTime + activeElement.getNumber('start') + activeElement.getNumber('offset'), totalPlaylistLength);
			}
			
			private function getFullVideoSource():String {
				return(activeElement.getString('videoSource') + '?start=' + encodeURIComponent(activeElement.getString('start')) + '&skip=' + encodeURIComponent(activeElement.getString('skip')));
			}            
			
			// Which video display are we binding to? (and attach to events)
			private var _targetVideo:VisualVideo;
			public function set targetVideo(v:VisualVideo):void {
				_targetVideo = v;
				v.addEventListener(VideoEvent.PLAYHEAD_UPDATE, updatePlay);
			}
			public function get targetVideo():VisualVideo {return(_targetVideo);}
			
			public function placeGrid():void {
				videoGrid.removeAllChildren();
				for (var i:int = 0; i<_photos.length; i++) {
					var g:Canvas = new mx.containers.Canvas;
					g.height = this.height;
					g.width = (new Number(_photos[i].video_length) / totalPlaylistLength * this.width);
					g.setStyle('borderThickness', '1');
					g.setStyle('borderColor', '#aaaaaa');
					g.setStyle('borderStyle', 'solid');
					g.setStyle('borderSides', 'right');
					videoGrid.addChild(g);
				}
			}
		]]>
	</mx:Script>	
</mx:Canvas>
